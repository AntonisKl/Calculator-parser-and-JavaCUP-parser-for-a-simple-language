/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;
// import java.lang.reflect.InvocationTargetException;
// import java.lang.reflect.Method;

/**
 *  Usercode Components
 */

action code {:
    // My methods
    // public String callMethodByName(String name, String obj, String arg) {
    //     java.lang.reflect.Method method;

    //     try {
    //         method = obj.getClass().getMethod(name, arg.getClass());
    //     } catch (SecurityException e) { e.printStackTrace(); }
    //     catch (NoSuchMethodException e) { e.printStackTrace(); }

    //     try {
    //         return (String) method.invoke(obj, arg);
    //     } catch (IllegalArgumentException e) {  e.printStackTrace(); }
    //     catch (IllegalAccessException e) {  e.printStackTrace(); }
    //     catch (InvocationTargetException e) {  e.printStackTrace(); }
    // }

    String buildStatement(String s) {
        return s + ";\n";
    }

    String buildStringConstant(String s) {
        return "\"" + s + "\"";
    }

    String buildConditional(String condition, String s1, String s2) {
        return condition + " ? " + s1 + " : " + s2 + "";
    }

    String buildParams(String firstParam, String moreParams) {
        return firstParam + ", " + moreParams;
    }

    String buildFunctionDeclaration(String functionStart, String params, String statement) {
        return "public static String " + functionStart + params + ") {\n\treturn " + statement + ";\n}\n\n";
    }

    String buildFunctionCall(String functionStart, String params) {
        return functionStart + params + ")";
    }

    String buildBuiltInFunctionCall(String s1, String functionName, String s2) {
        return s1 + "." + functionName + "(" + s2 + ")";
    }
:};

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:};

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            PLUS, LPAREN, RPAREN, LBRACE, RBRACE, IF_START, ELSE, SUFFIX, PREFIX, COMMA, TRIPLE_LINE_TERMINATOR;
terminal String     STRING_LITERAL, IDENTIFIER, FUNCTION_START;

/*  Non terminals */
non terminal String functions, statement, builtin_functions, declarations, statements, params, param, ifelse, concatenation,
                        function_call, operand, params_call, param_call, expr_list;
// non terminal Integer    expr;      // used to store evaluated subexpressions

/**
 *  Precedence Declarations
 */
// precedence left PLUS, MINUS;
// precedence left TIMES;
precedence left IF_START, ELSE;
precedence left PREFIX, SUFFIX;
precedence left PLUS;

/**
 *  The Grammar Rules
 */

expr_list ::= declarations:decl TRIPLE_LINE_TERMINATOR statements:s  {: String result = decl + s; System.out.println(result); RESULT = result; :}
;
declarations ::= FUNCTION_START:functionStart params:p RPAREN LBRACE statement:s RBRACE declarations:decl     {: RESULT = buildFunctionDeclaration(functionStart, p, s) + decl; :}
                |                                                                                              {: RESULT = ""; :}
                ;
params ::= param:p                           {: RESULT = p; :}
          | /* empty */                      {: RESULT = ""; :}
          ;
param ::= IDENTIFIER:id COMMA param:p        {: RESULT = buildParams(id, p); :}
          | IDENTIFIER:id                    {: RESULT = id; :}
          ;
statements ::= function_call:s statements:moreS                 {: RESULT = buildStatement(s) + moreS; :}
              | /* empty */                                 {: RESULT = ""; :}
              ;
statement ::= ifelse:ifElse                         {: RESULT = ifElse; :}
             | concatenation:concat                 {: RESULT = concat; :}
             | function_call:function               {: RESULT = function; :}
            //  | builtin_functions:builtInFunction    {: RESULT = builtInFunction; :}
             | IDENTIFIER:id                           {: RESULT = id; :}
             | STRING_LITERAL:s                     {: RESULT = buildStringConstant(s); :}
             ;
ifelse ::= IF_START builtin_functions:condition RPAREN statement:s1 ELSE statement:s2        {: RESULT = buildConditional(condition, s1, s2); :}
;
concatenation ::= statement:s1 PLUS statement:s2 {: RESULT = s1 + " + " + s2; :}
                ;
// operand ::= IDENTIFIER:id                           {: RESULT = id; :}
//            | STRING_LITERAL:s                       {: RESULT = s; :}
//            ;
function_call ::= FUNCTION_START:functionStart params_call:params RPAREN    {: RESULT = buildFunctionCall(functionStart, params); :}
;
params_call ::= param_call:param                     {: RESULT = param; :}
               | /* empty */                         {: RESULT = ""; :}
               ;
param_call ::= statement:s COMMA param_call:param              {: RESULT = buildParams(s, param); :}
              | statement:s                                    {: RESULT = s; :}
              ;
builtin_functions ::= statement:s1 functions:f statement:s2 {: RESULT = buildBuiltInFunctionCall(s1, f, s2); :}
;
functions ::= SUFFIX        {: RESULT = "endsWith"; :}
             | PREFIX       {: RESULT = "startsWith"; :}
             ;

// old

// expr_list ::= expr_list expr:e SEMI         {: System.out.println(e);         :}
//             | expr:e SEMI                   {: System.out.println(e);         :}
// ;
// expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;                :}
//              | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;                :}
//              | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;                :}
//              | LPAREN expr:e RPAREN	        {: RESULT = e;                    :}
//              | STRING_LITERAL:s	            {: RESULT = Integer.parseInt(s);  :}
//              ;
