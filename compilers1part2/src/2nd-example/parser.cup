/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;
import java.io.FileWriter;
import java.io.IOException;

/**
 *  Usercode Components
 */
action code {:
    void writeToFile(String text) {
        try {
            FileWriter fileWriter = new FileWriter("output/Main.java", false);
            fileWriter.write(text);
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    String buildMainClass(String contents) {
        return "public class Main {\n" + contents + "}";
    }

    String buildMainFunction(String contents) {
        return "\tpublic static void main(String[] args) {\n" + contents + "\t}\n";
    }

    String buildStatement(String s) {
        return "\t\t" + s + ";\n";
    }

    String buildStringConstant(String s) {
        return "\"" + s + "\"";
    }

    String buildConditional(String condition, String s1, String s2) {
        return condition + " ? " + s1 + " : " + s2 + "";
    }

    String buildParams(String firstParam, String moreParams) {
        return firstParam + ", " + moreParams;
    }

    String buildFunctionDeclaration(String functionStart, String statement) {
        return "\tpublic static String " + functionStart + "\n\t\treturn " + statement + ";\n\t}\n\n";
    }

    String buildFunctionCall(String functionStart, String params) {
        return functionStart + params + ")";
    }

    String buildBuiltInFunctionCall(String s1, String functionName, String s2) {
        return s1 + "." + functionName + "(" + s2 + ")";
    }
:};

parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:};

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            PLUS, LPAREN, RPAREN, LBRACE, RBRACE, IF_START, ELSE, SUFFIX, PREFIX, COMMA, TRIPLE_LINE_TERMINATOR;
terminal String     STRING_LITERAL, IDENTIFIER, FUNCTION_START, FUNCTION_DECLARATION_START;

/*  Non terminals */
non terminal String functions, statement, builtin_functions, declarations, statements, params, param, ifelse, concatenation,
                        function_call, operand, params_call, param_call, expr_list;
// non terminal Integer    expr;      // used to store evaluated subexpressions

/**
 *  Precedence Declarations
 */
// precedence left PLUS, MINUS;
// precedence left TIMES;
precedence left IF_START, ELSE;
precedence left PREFIX, SUFFIX;
precedence left PLUS;

/**
 *  The Grammar Rules
 */

expr_list ::= declarations:decl statements:s  {: String result = buildMainClass(decl + buildMainFunction(s));
                                                 writeToFile(result);
                                                 System.out.println(result); RESULT = result; :}
;
declarations ::= FUNCTION_DECLARATION_START:functionStart statement:s RBRACE declarations:decl     {: RESULT = buildFunctionDeclaration(functionStart, s) + decl; :}
                |                                                                                              {: RESULT = ""; :}
                ;
statements ::= function_call:s statements:moreS             {: RESULT = buildStatement(s) + moreS; :}
              | /* empty */                                 {: RESULT = ""; :}
              ;
statement ::= ifelse:ifElse                         {: RESULT = ifElse; :}
             | concatenation:concat                 {: RESULT = concat; :}
             | function_call:function               {: RESULT = function; :}
            //  | builtin_functions:builtInFunction    {: RESULT = builtInFunction; :}
             | IDENTIFIER:id                           {: RESULT = id; :}
             | STRING_LITERAL:s                     {: RESULT = buildStringConstant(s); :}
             ;
ifelse ::= IF_START builtin_functions:condition RPAREN statement:s1 ELSE statement:s2        {: RESULT = buildConditional(condition, s1, s2); :}
;
concatenation ::= statement:s1 PLUS statement:s2 {: RESULT = s1 + " + " + s2; :}
                ;
// operand ::= IDENTIFIER:id                           {: RESULT = id; :}
//            | STRING_LITERAL:s                       {: RESULT = s; :}
//            ;
function_call ::= FUNCTION_START:functionStart params_call:params RPAREN    {: RESULT = buildFunctionCall(functionStart, params); :}
;
params_call ::= param_call:param                     {: RESULT = param; :}
               | /* empty */                         {: RESULT = ""; :}
               ;
param_call ::= statement:s COMMA param_call:param              {: RESULT = buildParams(s, param); :}
              | statement:s                                    {: RESULT = s; :}
              ;
builtin_functions ::= statement:s1 functions:f statement:s2 {: RESULT = buildBuiltInFunctionCall(s1, f, s2); :}
;
functions ::= SUFFIX        {: RESULT = "endsWith"; :}
             | PREFIX       {: RESULT = "startsWith"; :}
             ;

// old

// expr_list ::= expr_list expr:e SEMI         {: System.out.println(e);         :}
//             | expr:e SEMI                   {: System.out.println(e);         :}
// ;
// expr      ::= expr:e1 PLUS  expr:e2         {: RESULT = e1+e2;                :}
//              | expr:e1 MINUS expr:e2        {: RESULT = e1-e2;                :}
//              | expr:e1 TIMES expr:e2        {: RESULT = e1*e2;                :}
//              | LPAREN expr:e RPAREN	        {: RESULT = e;                    :}
//              | STRING_LITERAL:s	            {: RESULT = Integer.parseInt(s);  :}
//              ;
